Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Netty知识体系

## BIO、NIO、AIO

### 使用场景

#### BIO：连接数少且固定的架构

#### NIO：连接数多且连接比较短（轻操作：弹幕，聊天）

#### AIO：连接数多且连接比较长（重操作：相册服务器）

## BIO详解（Blocking I/O）

### 主要是通过线程池机制做改善，达到多客户连接服务器

### BIO编程流程

#### 写一个实例

#### BIO问题分析

##### 1\. 每个请求都需要创建独立的线程,与对应的客户端进行数据的Read,业务处理,数据Write

##### 2\.当并发数较大的时候,需要创建大量线程来处理连接,系统资源占用较大

##### 3\.连接建立之后,如果当前线程暂时没有数据可读,则线程就阻塞在Read操作上,造成线程资源的浪费\.

##### 因此, BIO适合事件驱动的模型, 就是当事件请求的时候, 才创建线程响应连接

## NIO详解\(non\-blocking I/O\)

### 说明

#### NIO可以看做是面向缓冲区\(块\)编程的\.

### 与BIO对比

#### 1\.BIO以流的方式处理数据,而NIO以块的方式处理数据,块I/O的效率比流I/O高很多

#### 2\.BIO是阻塞的,NIO是非阻塞的

#### 3\.BIO基于字节流和字符流进行操作的,而NIO基于Channel,Buffer进行操作,Selector用于监听多个通道的事件,因此使用单个线程就可以监听多个客户端通道\.

### 三大核心\(java\.nio包下\)

#### Channel\(通道\): 可以对应理解为BIO里面的Socket

#### Buffer\(缓冲区\)

#### Selector\(选择器\)
